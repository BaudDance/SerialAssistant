import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'

describe('ËµÑÊ∫êÊ∏ÖÁêÜÊµãËØï', () => {
  let mockConsole

  beforeEach(() => {
    // Mock console methods
    mockConsole = {
      log: vi.fn(),
      error: vi.fn(),
      warn: vi.fn(),
    }
    global.console = mockConsole

    // Mock global functions
    global.addEventListener = vi.fn()
    global.removeEventListener = vi.fn()

    // Mock document
    global.document = {
      title: 'SerialAssistant',
    }

    // Mock navigator
    global.navigator = {
      onLine: true,
    }

    vi.clearAllMocks()
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('‰∏≤Âè£ËµÑÊ∫êÊ∏ÖÁêÜÈÄªËæë', () => {
    it('Â∫îËØ•Ê≠£Á°ÆÊ∏ÖÁêÜ‰∏≤Âè£ËøûÊé•', async () => {
      // Ê®°Êãü‰∏≤Âè£ÂØπË±°
      const mockPort = {
        close: vi.fn().mockResolvedValue(undefined),
      }

      const mockReader = {
        cancel: vi.fn().mockResolvedValue(undefined),
        closed: Promise.resolve(),
      }

      // Ê®°Êãü‰∏≤Âè£Ê∏ÖÁêÜÈÄªËæë
      const closePort = async () => {
        console.log('üîå ÂºÄÂßãÂÖ≥Èó≠‰∏≤Âè£ËøûÊé•...')

        try {
          // ÂèñÊ∂àËØªÂèñÂô®
          if (mockReader) {
            await mockReader.cancel()
            await mockReader.closed
          }

          // ÂÖ≥Èó≠Á´ØÂè£
          if (mockPort) {
            await mockPort.close()
          }

          console.log('‚úÖ ‰∏≤Âè£ËøûÊé•Â∑≤ÂÆåÂÖ®ÂÖ≥Èó≠')
        }
        catch (error) {
          console.error('‚ùå ÂÖ≥Èó≠‰∏≤Âè£Êó∂Âá∫Èîô:', error)
        }
      }

      await closePort()

      // È™åËØÅÊ∏ÖÁêÜÊ≠•È™§
      expect(mockReader.cancel).toHaveBeenCalled()
      expect(mockPort.close).toHaveBeenCalled()
      expect(mockConsole.log).toHaveBeenCalledWith('üîå ÂºÄÂßãÂÖ≥Èó≠‰∏≤Âè£ËøûÊé•...')
      expect(mockConsole.log).toHaveBeenCalledWith('‚úÖ ‰∏≤Âè£ËøûÊé•Â∑≤ÂÆåÂÖ®ÂÖ≥Èó≠')
    })

    it('Â∫îËØ•Â§ÑÁêÜ‰∏≤Âè£ÂÖ≥Èó≠ÈîôËØØ', async () => {
      const mockPort = {
        close: vi.fn().mockRejectedValue(new Error('ÂÖ≥Èó≠Â§±Ë¥•')),
      }

      const closePort = async () => {
        console.log('üîå ÂºÄÂßãÂÖ≥Èó≠‰∏≤Âè£ËøûÊé•...')

        try {
          await mockPort.close()
          console.log('‚úÖ ‰∏≤Âè£ËøûÊé•Â∑≤ÂÆåÂÖ®ÂÖ≥Èó≠')
        }
        catch (error) {
          console.error('‚ùå ÂÖ≥Èó≠‰∏≤Âè£Êó∂Âá∫Èîô:', error)
        }
      }

      await closePort()

      expect(mockPort.close).toHaveBeenCalled()
      expect(mockConsole.error).toHaveBeenCalledWith('‚ùå ÂÖ≥Èó≠‰∏≤Âè£Êó∂Âá∫Èîô:', expect.any(Error))
    })
  })

  describe('ËìùÁâôËµÑÊ∫êÊ∏ÖÁêÜÈÄªËæë', () => {
    it('Â∫îËØ•Ê≠£Á°ÆÊ∏ÖÁêÜËìùÁâôËøûÊé•', async () => {
      const mockDevice = {
        gatt: {
          disconnect: vi.fn(),
        },
        removeEventListener: vi.fn(),
      }

      const mockCharacteristic = {
        removeEventListener: vi.fn(),
      }

      // Ê®°ÊãüËìùÁâôÊ∏ÖÁêÜÈÄªËæë
      const disconnectDevice = async () => {
        console.log('üîµ ÂºÄÂßãÊñ≠ÂºÄËìùÁâôËøûÊé•...')

        try {
          // ÁßªÈô§‰∫ã‰ª∂ÁõëÂê¨Âô®
          if (mockDevice) {
            mockDevice.removeEventListener('gattserverdisconnected', expect.any(Function))
          }

          if (mockCharacteristic) {
            mockCharacteristic.removeEventListener('characteristicvaluechanged', expect.any(Function))
          }

          // Êñ≠ÂºÄGATTËøûÊé•
          if (mockDevice?.gatt) {
            mockDevice.gatt.disconnect()
          }

          console.log('‚úÖ ËìùÁâôËøûÊé•Â∑≤ÂÆåÂÖ®Êñ≠ÂºÄ')
        }
        catch (error) {
          console.error('‚ùå Êñ≠ÂºÄËìùÁâôËøûÊé•Êó∂Âá∫Èîô:', error)
        }
      }

      await disconnectDevice()

      expect(mockDevice.gatt.disconnect).toHaveBeenCalled()
      expect(mockDevice.removeEventListener).toHaveBeenCalled()
      expect(mockCharacteristic.removeEventListener).toHaveBeenCalled()
      expect(mockConsole.log).toHaveBeenCalledWith('üîµ ÂºÄÂßãÊñ≠ÂºÄËìùÁâôËøûÊé•...')
      expect(mockConsole.log).toHaveBeenCalledWith('‚úÖ ËìùÁâôËøûÊé•Â∑≤ÂÆåÂÖ®Êñ≠ÂºÄ')
    })
  })

  describe('ÁΩëÁªúÁä∂ÊÄÅÁõëÂê¨Âô®Ê∏ÖÁêÜ', () => {
    it('Â∫îËØ•Ê≠£Á°ÆÊ∑ªÂä†ÂíåÁßªÈô§ÁΩëÁªúÁõëÂê¨Âô®', () => {
      const offlinePrefix = '[Offline] '

      // Ê®°ÊãüÁΩëÁªúÁõëÂê¨Âô®ÈÄªËæë
      const listenNetworkStatus = () => {
        const offlineHandler = () => {
          console.log('Network: Offline')
          document.title = offlinePrefix + document.title
        }

        const onlineHandler = () => {
          console.log('Network: Online')
          document.title = document.title.replace(offlinePrefix, '')
        }

        addEventListener('offline', offlineHandler)
        addEventListener('online', onlineHandler)

        // Initial title
        if (!navigator.onLine) {
          document.title = offlinePrefix + document.title
        }

        // ËøîÂõûÊ∏ÖÁêÜÂáΩÊï∞
        return () => {
          removeEventListener('offline', offlineHandler)
          removeEventListener('online', onlineHandler)
          console.log('Network status listeners removed')
        }
      }

      const cleanup = listenNetworkStatus()

      // È™åËØÅÁõëÂê¨Âô®Ë¢´Ê∑ªÂä†
      expect(global.addEventListener).toHaveBeenCalledWith('offline', expect.any(Function))
      expect(global.addEventListener).toHaveBeenCalledWith('online', expect.any(Function))

      // Ë∞ÉÁî®Ê∏ÖÁêÜÂáΩÊï∞
      cleanup()

      // È™åËØÅÁõëÂê¨Âô®Ë¢´ÁßªÈô§
      expect(global.removeEventListener).toHaveBeenCalledWith('offline', expect.any(Function))
      expect(global.removeEventListener).toHaveBeenCalledWith('online', expect.any(Function))
      expect(mockConsole.log).toHaveBeenCalledWith('Network status listeners removed')
    })

    it('Â∫îËØ•Ê≠£Á°ÆÊõ¥Êñ∞Á¶ªÁ∫øÁä∂ÊÄÅÊ†áÈ¢ò', () => {
      global.navigator.onLine = false
      const offlinePrefix = '[Offline] '

      const listenNetworkStatus = () => {
        // Initial title
        if (!navigator.onLine) {
          document.title = offlinePrefix + document.title
        }
      }

      listenNetworkStatus()

      expect(document.title).toBe('[Offline] SerialAssistant')
    })
  })

  describe('ÂÆöÊó∂Âô®Ê∏ÖÁêÜÈÄªËæë', () => {
    it('Â∫îËØ•Ê≠£Á°ÆÊ∏ÖÁêÜÂÆöÊó∂Âô®', () => {
      let timerId = 0
      const mockSetInterval = vi.fn(() => ++timerId)
      const mockClearInterval = vi.fn()

      global.setInterval = mockSetInterval
      global.clearInterval = mockClearInterval

      // Ê®°ÊãüÂÆöÊó∂Âô®ÁÆ°ÁêÜ
      const createTimerManager = () => {
        const timers = new Set()

        const addTimer = (callback, delay) => {
          const id = setInterval(callback, delay)
          timers.add(id)
          return id
        }

        const cleanup = () => {
          timers.forEach((id) => {
            clearInterval(id)
          })
          timers.clear()
        }

        return { addTimer, cleanup, getTimerCount: () => timers.size }
      }

      const manager = createTimerManager()

      // Ê∑ªÂä†ÂÆöÊó∂Âô®
      manager.addTimer(() => {}, 1000)
      manager.addTimer(() => {}, 2000)

      expect(manager.getTimerCount()).toBe(2)
      expect(mockSetInterval).toHaveBeenCalledTimes(2)

      // Ê∏ÖÁêÜÂÆöÊó∂Âô®
      manager.cleanup()

      expect(manager.getTimerCount()).toBe(0)
      expect(mockClearInterval).toHaveBeenCalledTimes(2)
    })
  })

  describe('È°µÈù¢Âç∏ËΩΩ‰∫ã‰ª∂Â§ÑÁêÜ', () => {
    it('Â∫îËØ•Ê≠£Á°ÆÂ§ÑÁêÜbeforeunload‰∫ã‰ª∂', () => {
      const mockAddEventListener = vi.fn()
      global.addEventListener = mockAddEventListener

      // Ê®°ÊãüÈ°µÈù¢Âç∏ËΩΩÂ§ÑÁêÜ
      const setupBeforeUnloadHandler = () => {
        const handleBeforeUnload = () => {
          console.log('È°µÈù¢Âç≥Â∞ÜÂç∏ËΩΩÔºåÊ∏ÖÁêÜËµÑÊ∫ê...')
          // ËøôÈáå‰ºöË∞ÉÁî®ÂêÑÁßçÊ∏ÖÁêÜÂáΩÊï∞
        }

        addEventListener('beforeunload', handleBeforeUnload)

        return handleBeforeUnload
      }

      const handler = setupBeforeUnloadHandler()

      expect(mockAddEventListener).toHaveBeenCalledWith('beforeunload', handler)

      // Ê®°ÊãüËß¶Âèë‰∫ã‰ª∂
      handler()

      expect(mockConsole.log).toHaveBeenCalledWith('È°µÈù¢Âç≥Â∞ÜÂç∏ËΩΩÔºåÊ∏ÖÁêÜËµÑÊ∫ê...')
    })
  })

  describe('ÈîôËØØÂ§ÑÁêÜÂíåËæπÁïåÊÉÖÂÜµ', () => {
    it('Â∫îËØ•Â§ÑÁêÜÁ©∫ÂØπË±°ÁöÑÊ∏ÖÁêÜ', async () => {
      const safeCleanup = async (resource, cleanupFn) => {
        try {
          if (resource && typeof cleanupFn === 'function') {
            await cleanupFn()
          }
        }
        catch (error) {
          console.error('Ê∏ÖÁêÜËµÑÊ∫êÊó∂Âá∫Èîô:', error)
        }
      }

      // ÊµãËØïÁ©∫ÂØπË±°
      await safeCleanup(null, null)
      await safeCleanup(undefined, undefined)

      // ÊµãËØïÊúâÊïàÂØπË±°
      const mockResource = { close: vi.fn() }
      await safeCleanup(mockResource, () => mockResource.close())

      expect(mockResource.close).toHaveBeenCalled()
    })

    it('Â∫îËØ•Â§ÑÁêÜÈáçÂ§çÊ∏ÖÁêÜË∞ÉÁî®', () => {
      let isCleanedUp = false

      const cleanup = () => {
        if (isCleanedUp) {
          console.log('ËµÑÊ∫êÂ∑≤ÁªèÊ∏ÖÁêÜËøá‰∫Ü')
          return
        }

        console.log('Ê≠£Âú®Ê∏ÖÁêÜËµÑÊ∫ê...')
        isCleanedUp = true
      }

      // Á¨¨‰∏ÄÊ¨°Ê∏ÖÁêÜ
      cleanup()
      expect(mockConsole.log).toHaveBeenCalledWith('Ê≠£Âú®Ê∏ÖÁêÜËµÑÊ∫ê...')

      // Á¨¨‰∫åÊ¨°Ê∏ÖÁêÜ
      cleanup()
      expect(mockConsole.log).toHaveBeenCalledWith('ËµÑÊ∫êÂ∑≤ÁªèÊ∏ÖÁêÜËøá‰∫Ü')
    })
  })

  describe('ËµÑÊ∫êÊ≥ÑÈú≤Ê£ÄÊµã', () => {
    it('Â∫îËØ•Ê£ÄÊµãÊú™Ê∏ÖÁêÜÁöÑËµÑÊ∫ê', () => {
      const resourceTracker = {
        resources: new Set(),

        addResource(resource) {
          this.resources.add(resource)
        },

        removeResource(resource) {
          this.resources.delete(resource)
        },

        getLeakedResources() {
          return Array.from(this.resources)
        },

        hasLeaks() {
          return this.resources.size > 0
        },
      }

      // Ê∑ªÂä†ËµÑÊ∫ê
      resourceTracker.addResource('port1')
      resourceTracker.addResource('device1')
      resourceTracker.addResource('timer1')

      expect(resourceTracker.hasLeaks()).toBe(true)
      expect(resourceTracker.getLeakedResources()).toHaveLength(3)

      // Ê∏ÖÁêÜÈÉ®ÂàÜËµÑÊ∫ê
      resourceTracker.removeResource('port1')

      expect(resourceTracker.hasLeaks()).toBe(true)
      expect(resourceTracker.getLeakedResources()).toHaveLength(2)

      // Ê∏ÖÁêÜÊâÄÊúâËµÑÊ∫ê
      resourceTracker.removeResource('device1')
      resourceTracker.removeResource('timer1')

      expect(resourceTracker.hasLeaks()).toBe(false)
      expect(resourceTracker.getLeakedResources()).toHaveLength(0)
    })
  })
})
